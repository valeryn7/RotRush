local levels = require "main.levels"
local rendercam = require "rendercam.rendercam"

local FOOTER_NAMES = { "item1", "item2", "item3" }
local SPAWN_EVERY = 0.8
local PAD = 32

local ITEM_BASE_SIZE = 160
local ITEM_WIDTH_FRAC = 0.18
local ITEM_SCALE_MIN = 0.85
local ITEM_SCALE_MAX = 1.6

-- Retorna l√≠mites para generar posici√≥n aleatoria de √≠tems
local function spawn_bounds()
	local w, h = rendercam.window.x, rendercam.window.y
	local left  = -w * 0.5 + PAD
	local right =  w * 0.5 - PAD
	local top   =  h * 0.5 + 64
	return left, right, top
end

-- Calcula escala de √≠tem seg√∫n resoluci√≥n de pantalla
local function item_scale_for_width()
	local w = rendercam.window.x
	local target_w = w * ITEM_WIDTH_FRAC
	local s = target_w / ITEM_BASE_SIZE
	if s < ITEM_SCALE_MIN then s = ITEM_SCALE_MIN end
	if s > ITEM_SCALE_MAX then s = ITEM_SCALE_MAX end
	return s
end

-- Devuelve si el jugador complet√≥ la receta del nivel
local function recipe_complete(self)
	for _, k in ipairs(self.level.target) do
		if not self.collected[k] then return false end
	end
	return true
end

-- Spawnea un √≠tem aleatorio de la pool
local function spawn_item(self)
	local filtered_pool = {}
	for _, cfg in ipairs(self.level.pool) do
		if not cfg.is_correct or not self.collected[cfg.kind] then
			table.insert(filtered_pool, cfg)
		end
	end

	if #filtered_pool == 0 then return end

	local cfg = filtered_pool[math.random(#filtered_pool)]
	local left, right, top = spawn_bounds()
	local x = left + math.random() * (right - left)
	local pos = vmath.vector3(x, top, 0)

	local s = item_scale_for_width()
	local id = factory.create("#item_factory", pos, nil, {
		kind       = cfg.kind,
		is_correct = cfg.is_correct,
		radius     = 80 * s  -- el radius se escala con el tama√±o del sprite
	})

	go.set_parent(id, self.screen_go, true)
	go.set_scale(vmath.vector3(s, s, 1), id)
	table.insert(self.active_items, id)
end

-- Actualiza el footer visual con los √≠tems recolectados
local function update_footer(self)
	local items = self.level.target
	local total = #items

	for i, kind in ipairs(items) do
		local go_name = FOOTER_NAMES[i]
		local sprite_id = go_name .. "#sprite"
		local collected = self.collected[kind]
		local tint = collected and vmath.vector4(1, 1, 1, 1) or vmath.vector4(1, 1, 1, 0.4)

		if go.exists(go_name) then
			sprite.play_flipbook(sprite_id, kind)
			sprite.set_constant(sprite_id, "tint", tint)
			msg.post(sprite_id, "enable")
		end
	end

	for i = total + 1, #FOOTER_NAMES do
		msg.post(FOOTER_NAMES[i] .. "#sprite", "disable")
	end

	msg.post("footer#footer_fit", "place_footer", { total = total })
end

function init(self)
	msg.post(".", "acquire_input_focus")
	math.randomseed(os.time())
	print("rendercam:", rendercam)
	
	self.level = levels.LEVELS[1]
	self.collected, self.target_set = {}, {}
	for _, k in ipairs(self.level.target) do
		self.target_set[k] = true
	end

	self.lives = 2
	self.spawn_timer = 0
	self.screen_go = go.get_parent()
	self.active_items = {}

	update_footer(self)
end

function update(self, dt)
	self.spawn_timer = self.spawn_timer + dt
	if self.spawn_timer >= SPAWN_EVERY then
		self.spawn_timer = self.spawn_timer - SPAWN_EVERY
		spawn_item(self)
	end

	if recipe_complete(self) then
		print("üéâ WIN Nivel 1")
		self.collected = {}
		update_footer(self)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("touch") and action.pressed then
		local world_pos = rendercam.screen_to_world_2d(action.screen_x, action.screen_y)

		-- Limpiar referencias inv√°lidas
		local valid_items = {}
		for _, item_id in ipairs(self.active_items) do
			if go.exists(item_id) then
				msg.post(item_id, "check_hit", {
					world_x = world_pos.x,
					world_y = world_pos.y,
					controller = go.get_id()
				})
				table.insert(valid_items, item_id)
			end
		end
		self.active_items = valid_items
	end
end

function on_message(self, message_id, message)
	if message_id == hash("item_picked") then
		print("üß™ picked:", message.kind, "| correcto:", message.is_correct)

		if message.is_correct and self.target_set[message.kind] then
			self.collected[message.kind] = true
			update_footer(self)
		else
			self.lives = self.lives - 1
			print("‚ùå fallo | vidas:", self.lives)
			if self.lives <= 0 then
				print("üíÄ GAME OVER")
				self.lives = 2
				self.collected = {}
				update_footer(self)
			end
		end

	elseif message_id == hash("item_destroyed") then
		for i, id in ipairs(self.active_items) do
			if id == message.id then
				table.remove(self.active_items, i)
				break
			end
		end
	end
end
